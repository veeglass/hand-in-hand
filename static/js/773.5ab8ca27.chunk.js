"use strict";(self.webpackChunkhan2han=self.webpackChunkhan2han||[]).push([[773],{34773:function(n,e,t){t.r(e),t.d(e,{OpenloginAdapter:function(){return b},getOpenloginDefaultOptions:function(){return P}});var i=t(15861),r=t(15671),o=t(43144),a=t(97326),s=t(11752),c=t(61120),h=t(60136),u=t(29388),l=t(87757),p=t.n(l),g=t(41163),f=t(37949),d=t(4942),v=t(57381),y=t.n(v),C=t(62895),N=t.n(C),P=function(n,e){return{adapterSettings:{network:g.dr.MAINNET,clientId:"",uxMode:g.$e.POPUP},chainConfig:n?(0,f.h2)(n,e):void 0,loginSettings:{relogin:!0}}};function O(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,i)}return t}function w(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?O(Object(t),!0).forEach((function(e){(0,d.Z)(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):O(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var b=function(n){(0,h.Z)(l,n);var e=(0,u.Z)(l);function l(n){var t,i,o,s;(0,r.Z)(this,l),t=e.call(this),(0,d.Z)((0,a.Z)(t),"name",f.rW.OPENLOGIN),(0,d.Z)((0,a.Z)(t),"adapterNamespace",f.yk.MULTICHAIN),(0,d.Z)((0,a.Z)(t),"type",f.hN.IN_APP),(0,d.Z)((0,a.Z)(t),"openloginInstance",null),(0,d.Z)((0,a.Z)(t),"status",f.MP.NOT_READY),(0,d.Z)((0,a.Z)(t),"currentChainNamespace",f.EN.EIP155),(0,d.Z)((0,a.Z)(t),"openloginOptions",void 0),(0,d.Z)((0,a.Z)(t),"loginSettings",{}),(0,d.Z)((0,a.Z)(t),"privKeyProvider",null),N().debug("const openlogin adapter",n);var c=P(null===(i=n.chainConfig)||void 0===i?void 0:i.chainNamespace,null===(o=n.chainConfig)||void 0===o?void 0:o.chainId);if(t.openloginOptions=w(w({clientId:"",network:g.dr.MAINNET},c.adapterSettings),n.adapterSettings||{}),t.loginSettings=w(w({},c.loginSettings),n.loginSettings),null!==(s=n.chainConfig)&&void 0!==s&&s.chainNamespace){var h;t.currentChainNamespace=null===(h=n.chainConfig)||void 0===h?void 0:h.chainNamespace;var u=c.chainConfig?c.chainConfig:{};if(t.chainConfig=w(w({},u),null===n||void 0===n?void 0:n.chainConfig),N().debug("const openlogin chainConfig",t.chainConfig),!t.chainConfig.rpcTarget)throw f.Ty.invalidParams("rpcTarget is required in chainConfig")}return t}return(0,o.Z)(l,[{key:"chainConfigProxy",get:function(){return this.chainConfig?w({},this.chainConfig):null}},{key:"provider",get:function(){var n;return(null===(n=this.privKeyProvider)||void 0===n?void 0:n.provider)||null},set:function(n){throw new Error("Not implemented")}},{key:"init",value:function(){var n=(0,i.Z)(p().mark((function n(e){var t,i,r;return p().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if((0,s.Z)((0,c.Z)(l.prototype),"checkInitializationRequirements",this).call(this),null!==(t=this.openloginOptions)&&void 0!==t&&t.clientId){n.next=3;break}throw f.Ty.invalidParams("clientId is required before openlogin's initialization");case 3:if(this.chainConfig){n.next=5;break}throw f.Ty.invalidParams("chainConfig is required before initialization");case 5:return this.openloginInstance=new g.ZP(this.openloginOptions),i=(0,g.Gv)(),r=!0,Object.keys(i).length>0&&i.result&&(r=!0),n.next=11,this.openloginInstance.init();case 11:if(this.status=f.MP.READY,this.emit(f.n2.READY,f.rW.OPENLOGIN),n.prev=13,!this.openloginInstance.privKey||!e.autoConnect&&!r){n.next=17;break}return n.next=17,this.connect();case 17:n.next=23;break;case 19:n.prev=19,n.t0=n.catch(13),N().error("Failed to connect with cached openlogin provider",n.t0),this.emit("ERRORED",n.t0);case 23:case"end":return n.stop()}}),n,this,[[13,19]])})));return function(e){return n.apply(this,arguments)}}()},{key:"connect",value:function(){var n=(0,i.Z)(p().mark((function n(e){return p().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return(0,s.Z)((0,c.Z)(l.prototype),"checkConnectionRequirements",this).call(this),this.status=f.MP.CONNECTING,this.emit(f.n2.CONNECTING,w(w({},e),{},{adapter:f.rW.OPENLOGIN})),n.prev=3,n.next=6,this.connectWithProvider(e);case 6:return n.abrupt("return",this.provider);case 9:if(n.prev=9,n.t0=n.catch(3),N().error("Failed to connect with openlogin provider",n.t0),this.status=f.MP.READY,this.emit(f.n2.ERRORED,n.t0),null===n.t0||void 0===n.t0||!n.t0.message.includes("user closed popup")){n.next=16;break}throw f.RM.popupClosed();case 16:throw f.RM.connectionError("Failed to login with openlogin");case 17:case"end":return n.stop()}}),n,this,[[3,9]])})));return function(e){return n.apply(this,arguments)}}()},{key:"disconnect",value:function(){var n=(0,i.Z)(p().mark((function n(){var e,t=arguments;return p().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(e=t.length>0&&void 0!==t[0]?t[0]:{cleanup:!1},this.status===f.MP.CONNECTED){n.next=3;break}throw f.RM.notConnectedError("Not connected with wallet");case 3:if(this.openloginInstance){n.next=5;break}throw f.Ty.notReady("openloginInstance is not ready");case 5:return n.next=7,this.openloginInstance.logout();case 7:e.cleanup?(this.status=f.MP.NOT_READY,this.openloginInstance=null,this.privKeyProvider=null):this.status=f.MP.READY,this.emit(f.n2.DISCONNECTED);case 9:case"end":return n.stop()}}),n,this)})));return function(){return n.apply(this,arguments)}}()},{key:"getUserInfo",value:function(){var n=(0,i.Z)(p().mark((function n(){var e;return p().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(this.status===f.MP.CONNECTED){n.next=2;break}throw f.RM.notConnectedError("Not connected with wallet");case 2:if(this.openloginInstance){n.next=4;break}throw f.Ty.notReady("openloginInstance is not ready");case 4:return n.next=6,this.openloginInstance.getUserInfo();case 6:return e=n.sent,n.abrupt("return",e);case 8:case"end":return n.stop()}}),n,this)})));return function(){return n.apply(this,arguments)}}()},{key:"setAdapterSettings",value:function(n){if(this.status!==f.MP.READY){var e=P();this.openloginOptions=w(w(w({},e.adapterSettings),this.openloginOptions||{}),n)}}},{key:"setChainConfig",value:function(n){(0,s.Z)((0,c.Z)(l.prototype),"setChainConfig",this).call(this,n),this.currentChainNamespace=n.chainNamespace}},{key:"connectWithProvider",value:function(){var n=(0,i.Z)(p().mark((function n(e){var i,r,o,a,s,c,h;return p().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(this.chainConfig){n.next=2;break}throw f.Ty.invalidParams("chainConfig is required before initialization");case 2:if(this.openloginInstance){n.next=4;break}throw f.Ty.notReady("openloginInstance is not ready");case 4:if(this.currentChainNamespace!==f.EN.SOLANA){n.next=12;break}return n.next=7,Promise.all([t.e(87),t.e(201),t.e(823),t.e(23)]).then(t.bind(t,63823));case 7:i=n.sent,r=i.SolanaPrivateKeyProvider,this.privKeyProvider=new r({config:{chainConfig:this.chainConfig}}),n.next=21;break;case 12:if(this.currentChainNamespace!==f.EN.EIP155){n.next=20;break}return n.next=15,Promise.all([t.e(87),t.e(256),t.e(917)]).then(t.bind(t,19256));case 15:o=n.sent,a=o.EthereumPrivateKeyProvider,this.privKeyProvider=new a({config:{chainConfig:this.chainConfig}}),n.next=21;break;case 20:throw new Error("Invalid chainNamespace: ".concat(this.currentChainNamespace," found while connecting to wallet"));case 21:if(this.openloginInstance.privKey||!e){n.next=24;break}return n.next=24,this.openloginInstance.login(y()(this.loginSettings,{loginProvider:e.loginProvider},{extraLoginOptions:{login_hint:null===e||void 0===e?void 0:e.login_hint}}));case 24:if(!(s=this.openloginInstance.privKey)){n.next=36;break}if(this.currentChainNamespace!==f.EN.SOLANA){n.next=32;break}return n.next=29,Promise.all([t.e(201),t.e(921)]).then(t.bind(t,84656));case 29:c=n.sent,h=c.getED25519Key,s=h(s).sk.toString("hex");case 32:return n.next=34,this.privKeyProvider.setupProvider(s);case 34:this.status=f.MP.CONNECTED,this.emit(f.n2.CONNECTED,{adapter:f.rW.OPENLOGIN,reconnected:!e});case 36:case"end":return n.stop()}}),n,this)})));return function(e){return n.apply(this,arguments)}}()}]),l}(f.J5)}}]);
//# sourceMappingURL=773.5ab8ca27.chunk.js.map